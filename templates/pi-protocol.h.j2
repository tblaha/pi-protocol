// THIS FILE HAS BEEN AUTOGENERATED BY generate_header.py, DO NOT MODIFY

#ifndef PI_PROTOCOL_H
#define PI_PROTOCOL_H

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include <stdint.h>
#include <stdbool.h>

// --- Protocol definition ---
#define PI_VERSION_MAJOR {{ config.version.major }}
#define PI_VERSION_MINOR {{ config.version.minor }}
#define PI_VERSION_PATCH {{ config.version.patch }}

// message format: | STX | MSG_ID | PAYLOAD_1 | PAYLOAD_2 | ... | PAYLOAD_N |
// if STX occurs in PAYLOAD or MSG_ID, it is escaped by the sequency PI_ESC PI_STX_ESC
// if ESC occurs in PAYLOAD or MSG_ID, it is escaped by the sequence PI_ESC PI_ESC_ESC
#define PI_STX 0xFE
#define PI_ESC 0x01
#define PI_STX_ESC 0x02
#define PI_ESC_ESC 0x03
#define PI_MSG_MAX_PAYLOAD_LEN 0x100
#define PI_MSG_ID_LEN 1
#define PI_MAX_PACKET_LEN (PI_MSG_MAX_PAYLOAD_LEN + PI_MSG_ID_LEN)

// --- global mode ---
#define PI_TX   1 << 0
#define PI_RX   1 << 1
#define PI_RXTX (PI_TX | PI_RX)

// --- Message flags ---
#define PI_MSG_NONE_ID 0xFF
#define PI_MSG_MAX_ID 0xFE

#define PI_MSG_NONE 0
#define PI_MSG_TX   1 << 0
#define PI_MSG_RX   1 << 1
#define PI_MSG_RXTX (PI_MSG_TX | PI_MSG_RX)

// --- Global mode config ---
#define PI_MODE PI_{{ config.global_mode }}

// --- serializer ---
#if (PI_MODE & PI_TX)
#define PI_PAYLOAD_TO_BUFFER(_BUFFER, _PAYLOAD, _LEN) \
    memcpy((_BUFFER)+PI_MSG_ID_LEN, (const uint8_t *)( &(_PAYLOAD)), _LEN )

static inline void piSerialWrite(void (*serialWriter)(uint8_t byte), uint8_t * buf, uint16_t length)
{
    serialWriter(PI_STX);
    for (int i = 0; i < length; i++)
        switch(buf[i]) {
            case PI_STX:
                serialWriter(PI_ESC);
                serialWriter(PI_STX_ESC);
                break;
            case PI_ESC:
                serialWriter(PI_ESC);
                serialWriter(PI_ESC_ESC);
                break;
            default:
                serialWriter(buf[i]);
        }
}
#endif

// rx parsing states
#if (PI_MODE & PI_RX)
typedef enum {
    PI_MSG_RX_STATE_A,
    PI_MSG_RX_STATE_B,
    PI_MSG_RX_STATE_NONE
} pi_msg_rx_state_t;

typedef enum {
    PI_PARSE_MSG_NO_ERROR = -1,
    PI_PARSE_MSG_SUCCESS,
    PI_PARSE_MSG_INVALID_ID,
    PI_PARSE_MSG_EXCEEDS_MAX_PAYLOAD_LEN,
    PI_PARSE_MSG_EXCEEDS_MSG_PAYLOAD_LEN,
    PI_PARSE_MSG_NULL_BUFFER,
    PI_PARSE_MSG_NO_SUCH_MSG,
} pi_parse_msg_result_t;
#endif

#ifdef PI_STATS
// everything > PI_SUCCESS causes reset to PI_IDLE state.
typedef enum {
    PI_SUCCESS = PI_PARSE_MSG_SUCCESS,
    PI_INVALID_ID = PI_PARSE_MSG_INVALID_ID,
    PI_EXCEEDS_MAX_PAYLOAD_LEN = PI_PARSE_MSG_EXCEEDS_MAX_PAYLOAD_LEN,
    PI_EXCEEDS_MSG_PAYLOAD_LEN = PI_PARSE_MSG_EXCEEDS_MSG_PAYLOAD_LEN,
    PI_NULL_BUFFER = PI_PARSE_MSG_NULL_BUFFER,
    PI_NO_SUCH_MSG = PI_PARSE_MSG_NO_SUCH_MSG,
    PI_ESC_ERROR,
    PI_STX_COUNT,
    NUM_PI_STATS_RESULT,
} pi_stats_result_t;

uint piStats[NUM_PI_STATS_RESULT] = {0,0,0,0,  0,0,0,0};

const char* piStatsNames[NUM_PI_STATS_RESULT] = {
    "PI_SUCCESS",
    "PI_INVALID_ID",
    "PI_EXCEEDS_MAX_PAYLOAD_LEN",
    "PI_EXCEEDS_MSG_PAYLOAD_LEN",
    "PI_NULL_BUFFER",
    "PI_NO_SUCH_MSG",
    "PI_ESC_ERROR",
    "PI_STX_COUNT",
};

static void piPrintStats() {
    static int i = 0;
    printf("\n+------------ piPrintStats invokation %d -------------+\n", i++);
    printf("|%-30s|%-10s|\n", "Result", "Occurence");
    printf("|------------------------------|----------|\n");
    for (int i=0; i < NUM_PI_STATS_RESULT; i++)
        printf("|%-30s|%-10d|\n", piStatsNames[i], piStats[i]);
    printf("|------------------------------|----------|\n");
}
#endif

// --- messages ---
#include "pi-messages.h"

// --- parser ---
#if (PI_MODE & PI_RX)

typedef enum {
    PI_IDLE,
    PI_STX_FOUND,
    PI_ID_FOUND
} pi_parse_state_t;

static inline void piParse(uint8_t byte) {
    static bool piEscHit = false;
    static pi_parse_state_t piState = PI_IDLE;
    static uint8_t msgId = PI_MSG_NONE_ID;
    static uint8_t byteCount = 0;
    static pi_parse_msg_result_t msgParseResult = PI_PARSE_MSG_SUCCESS;

    if (byte == PI_STX) {
#ifdef PI_STATS
        piStats[PI_STX_COUNT]++;
#endif
        piEscHit = false;
        piState = PI_STX_FOUND;
        return;
    }

    if (piState == PI_IDLE)
        return;

    if (piEscHit) {
        piEscHit = false;
        switch(byte) {
            case PI_STX_ESC:
                byte = PI_STX;
                break;
            case PI_ESC_ESC:
                byte = PI_ESC;
                break;
            default:
                // failure, next byte MUST have been PI_STX_ESC or PI_ESC_ESC
#ifdef PI_DEBUG
                printf("Escaping error: next byte was neither PI_STX_ESC nor PI_ESC_ESC, but rather %02hhX\n", byte);
#endif
#ifdef PI_STATS
                piStats[PI_ESC_ERROR]++;
#endif
                piState = PI_IDLE;
                return;
        }
    } else {
        if (byte == PI_ESC) {
            piEscHit = true;
            return;
        }
    }


    switch(piState) {
        case PI_IDLE: // can never happen, so fall through to satisfy GCC -Wall
            break;
        case PI_STX_FOUND:
            // parse id
            msgId = byte;
            piState = PI_ID_FOUND;
            byteCount = 0;
            break;
        case PI_ID_FOUND:
            // payload time
            msgParseResult = piParseIntoMsg(msgId, byte, byteCount++);
#ifdef PI_STATS
            if (msgParseResult > PI_PARSE_MSG_NO_ERROR)
                /* either a messages has finished parsing (SUCCESS), or a fault
                   occured. The reason we only reset to PI_IDLE here is to make
                   sure any additional non STX bit triggers a
                   PI_PARSE_MSG_EXCEEDS_MSG_LEN error and is listed in the 
                   stats.*/
                piStats[msgParseResult]++;
#endif
            if (msgParseResult > PI_PARSE_MSG_SUCCESS) {
#ifdef PI_DEBUG
                printf("\n msgParseResult > PI_PARSE_MSG_SUCCESS at id 0x%02hhX, byte 0x%02hhX: %d\n", msgId, byte, msgParseResult);
#endif
                msgId = PI_MSG_NONE_ID;
                piState = PI_IDLE;
            }
            break;
    }
}

#endif// #if (PI_MODE & PI_RX)

#ifdef __cplusplus
}
#endif

#endif // PI_PROTOCOL_H
    
